-- 시퀀스 (순차적으로 증가하는 값 - PK에 많이 사용)
SELECT * FROM USER_SEQUENCES;

-- 시퀀스 생성
--CREATE SEQUENCE DEPT3_SEQ; -- 자동생성
CREATE SEQUENCE DEPT3_SEQ
    INCREMENT BY 1
    START WITH 1
    MAXVALUE 10
    NOCACHE -- 캐시개념을 사용X
    NOCYCLE; -- 사이클 사용X
    
-- 시퀀스 삭제
DROP SEQUENCE DEPT3_SEQ;

-- 적용할 테이블
CREATE TABLE DEPT3 (
    DEPT_NO NUMBER(2),
    DEPT_NAME VARCHAR(20),
    LOCA VARCHAR2(20),
    DEPT_DATE DATE
);
ALTER TABLE DEPT3 ADD CONSTRAINT DEPT3_PK PRIMARY KEY (DEPT_NO); -- PK

DESC DEPT3;

-- 시퀀스를 사용 (NEXTVAL, CURRVAL)
SELECT DEPT3_SEQ.CURRVAL FROM DUAL; -- NEXTVAL 한번 수행된 이후에 사용 가능

-- MAXVALUE가 10이기 때문에 10초과해서 증가하지 않는다.
INSERT INTO DEPT3(DEPT_NO, DEPT_NAME, LOCA, DEPT_DATE)
VALUES (DEPT3_SEQ.NEXTVAL, 'TEST', 'TEST', SYSDATE);

SELECT * FROM DEPT3;

-- 시퀀스 수정 (직접 수정도 가능)
ALTER SEQUENCE DEPT3_SEQ MAXVALUE 9999; -- MAX값 수정
ALTER SEQUENCE DEPT3_SEQ INCREMENT BY 10; -- 증가값 수정
ALTER SEQUENCE DEPT3_SEQ MINVALUE 1; -- MIN값 수정

-- 시퀀스가 테이블에서 사용되고 있는 경우라면 시퀀스를 DROP하면 안된다.
-- 시퀀스 초기화
-- 1. 현재 시퀀스 확인
SELECT DEPT3_SEQ.CURRVAL FROM DUAL;
-- 2. 증가값을 -현재시퀀스
ALTER SEQUENCE DEPT3_SEQ INCREMENT BY -59;
-- 3. NEXTVAL을 실행시켜 처음 시퀀스로 이동
SELECT DEPT3_SEQ.NEXTVAL FROM DUAL;
-- 4. 증가값을 다시 +1로 변경
ALTER SEQUENCE DEPT3_SEQ INCREMENT BY 1;
-- 이후에 NEXTVAL는 2에서 시작..

-- 시퀀스 사용의 응용
-- PK값을 VARCHAR2로 선언하고 202201시퀀스값) 형태로 사용

CREATE TABLE DEPT4(
    DEPT_NO VARCHAR2(30),
    DEPT_NAME VARCHAR2(30)
);
ALTER TABLE DEPT4 ADD CONSTRAINT DEPT4_PK PRIMARY KEY (DEPT_NO);
-- DPET4_SEQ먼저 생성하고
CREATE SEQUENCE DEPT4_SEQ
    INCREMENT BY 1
    START WITH 1
    MAXVALUE 31
    MINVALUE 1
    NOCACHE
    NOCYCLE;
-- LPAD('값', '맥스길이', '채울값')를 이용해서 PK에 적용하는 값을 (년월OOOO시퀀스)형태로 INSERT
INSERT INTO DEPT4 (DEPT_NO, DEPT_NAME)
VALUES (TO_CHAR(SYSDATE, 'YYMM')||LPAD(DEPT4_SEQ.NEXTVAL, 6, 'O'), 'TEST');

SELECT * FROM DEPT4;
COMMIT;

--------------------------------------------------------------------------------
-- INDEX
-- INDEX는 PK, UNIQUE에 자동으로 생성되고 , 조회를 빠르게 하는 HINT 역할을 함
-- INDEX종류로는 고유, 비고유 인덱스가 있다.
-- 고유 인덱스는 유니크한 컬럼에 적용되는 인덱스를 의미
-- 일반 컬럼에 인덱스를 적용하려면 UNIQUE르르 생략하고 생성

SELECT * FROM EMPS_IT WHERE FIRST_NAME = 'Nancy';

-- 인덱스 생성 (컬럼을 묶어서도 사용가능)
CREATE /*UNIQUE*/ INDEX EMPS_IT_IDX
ON EMPS_IT(FIRST_NAME);

-- 인덱스 삭제 (테이블에 큰 영향 미치지는 않음)
DROP INDEX EMPS_IT_IDX;

-- 인덱스 생성(결합 인덱스)
-- 첫번재 기술된 컬럼으로 조회 -> 두번째 기술된 컬럼으로 조회
CREATE INDEX EMPS_NAME_INDX
ON EMPS_IT(FIRST_NAME, LAST_NAME);

SELECT * FROM EMPS_IT WHERE FIRST_NAME = 'Nancy';
SELECT * FROM EMPS_IT WHERE FIRST_NAME = 'Nancy' AND LAST_NAME = 'Greenberg';

-- SELECT문의 INDEX기반으로 힌트를 주는 방법
CREATE TABLE TBL_BOARD(
    BNO NUMBER(10),
    WRITER VARCHAR(20)
);
ALTER TABLE TBL_BOARD ADD CONSTRAINT TBL_BOARD_PK PRIMARY KEY(BNO);
CREATE SEQUENCE TBL_BOARD_SEQ NOCACHE;

INSERT INTO TBL_BOARD VALUES (TBL_BOARD_SEQ.NEXTVAL, 'TEST1');
INSERT INTO TBL_BOARD VALUES (TBL_BOARD_SEQ.NEXTVAL, 'TEST2');
INSERT INTO TBL_BOARD VALUES (TBL_BOARD_SEQ.NEXTVAL, 'TEST3');
INSERT INTO TBL_BOARD VALUES (TBL_BOARD_SEQ.NEXTVAL, 'TEST4');
INSERT INTO TBL_BOARD VALUES (TBL_BOARD_SEQ.NEXTVAL, 'TEST5');
INSERT INTO TBL_BOARD VALUES (TBL_BOARD_SEQ.NEXTVAL, 'TEST6');
INSERT INTO TBL_BOARD VALUES (TBL_BOARD_SEQ.NEXTVAL, 'TEST7');
COMMIT;
SELECT * FROM TBL_BOARD;

--
SELECT *
FROM (SELECT ROWNUM AS RN,
             A.*
      FROM (SELECT *
            FROM TBL_BOARD
            ORDER BY BNO DESC) A
)
WHERE RN BETWEEN 11 AND 20;
--
SELECT *
FROM (SELECT /* +INDEX_DESC(TBL_BOARD_IDX) */
             ROWNUM RN,
             BNO,
             WRITER
      FROM TBL_BOARD
      ORDER BY BNO DESC
)
WHERE RN BETWEEN 11 AND 20;
